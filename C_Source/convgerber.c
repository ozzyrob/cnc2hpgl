/**
  * convgerber Convert Protel Autrax gerber to new format
  *
  * Written and maintained by Robert Murphy [ robert.murphy@gmx.com ]
  *
  * This purpose of this program to convert the gerber file generated by
  * Protel Autotrax to a newer format readable by FlatCAM & Gerbv
  *
  * Code logic based on hpgl-distiller by Paul L Daniels
  * 
  * Original version written: Tuesday 22 Nov 2016
  *
  *
  * Process description:
  *
  * convgerber -i src_filename -o dest_filename
  *
  **/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>

//* Not printable characters
#define BS 0x08
#define LF 0x0A
#define FF 0x0C
#define CR 0x0D
#define SPACE 0x20
#define GERBER_TERM 0x2A

//* Error number return values
#define ERR_SIZE_WRONG 0x08
#define ERR_SIG_WRONG 0x09
#define ERR_NO_BS_MAKER 0x0A 

#define ERR_NOT_OPEN_INPUT 0x01
#define ERR_NOT_OPEN_DRILL_GUIDE 0x01
#define ERR_NOT_OPEN_APERTURE 0x01
#define ERR_NOT_OPEN_TXT_OVL 0x01
#define ERR_NOT_OPEN_OUTPUT 0x01

#define ERR_NOT_VALID_INPUT 0x01
#define ERR_NOT_VALID_DRILL_GUIDE 0x01
#define ERR_NOT_VALID_TXT_OVL 0x01

#define ERR_GET_FILE_SIZE 0x01

#define ERR_ILLEGAL_CHAR 0x01
#define ERR_MISSING_M02 0x01

#define GCONV_VERSION "0.0.1"

const char  GCONV_HEADER[] = "G04 This is a Protel Autotrax gerber file converted by *\n"
					         "G04 convgerber V-0.0.1 *\n"
					         "G04 More information is available about convgerber at *\n"
                             "G04 https://github.com/ozzyrob/convgerber *\n"
                             "G04 --End of header info--*\n"
                             "%MOIN*%\n"
                             "%FSLAX23Y23*%\n"
                             "%IPPOS*%";

                       

const char APT_LIST_START[] = "G04 BEGIN APERTURE LIST*\n";
const char APT_LIST_END[] = "G04 END APERTURE LIST*\n";

const char LAYER_POLARITY_DARK[] = "G04 Set Layer Polarity to dark*\n%LPD*%\n";
const char LAYER_POLARITY_CLEAR[] = "G04 Set Layer Polarity to clear*\n%LPC*%\n";
             
const char STOP_MO2[] = "M02*\n";

const char AUTOTRAX_FILE_START_STRING[] = "X0Y0*";
                       
const char GCONV_HELP[]="convgerber: Protel gerber file converter\n"
	                    "Written by Robert Murphy.\n"
	                    "This software is available at https://github.com/ozzyrob/convgerber\n"
	                    "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n"
	                    "\n"
	                    "This is free software; you are free to change and redistribute it.\n"
	                    "There is NO WARRANTY, to the extent permitted by law.\n"
	                    "\n"
	                    "Usage: convgerber -i <input GERBER> -o <output file> [-g <optional drill guide]. [-v] [-h]\n"
	                    "\n"
	                    "\t-i <input GERBER> : Specifies which file contains the gerber file to convert.\n"
	                    "\t-g <input DRILL GUIDE> : Specifies which file contains the drill guide gerber to use.\n"
	                    "\t-o <output file> : specifies which file the converted gerber is to be saved to.\n"
	                    "\n"
	                    "\t-v : Display current software version\n"
	                    "\t-h : Display this help.\n"
	                    "\n";

struct gconv_glb {
	int status;
	int drill_guide_status;
	int txt_ovl_status;
	char *input_filename;
	char *output_filename;
	char *aperture_filename;
	char *drill_guide_filename;
	char *txt_ovl_filename;
};                       

/**
  * GCONV_show_version
  *
  * Display the current convgerber version
  */
int GCONV_show_version( struct gconv_glb *glb ) {
	fprintf(stderr,"%s\n", GCONV_VERSION);
	return 0;
}

/**
  * GCONV_show_help
  *
  * Display the help data for this program
  */
int GCONV_show_help( struct gconv_glb *glb ) {
	GCONV_show_version(glb);
	fprintf(stderr,"%s\n", GCONV_HELP);

	return 0;

}

/**
  * GCONV_init
  *
  * Initializes any variables or such as required by
  * the program.
  */
int GCONV_init( struct gconv_glb *glb )
{
	glb->status = 0;
	glb->drill_guide_status = 0;
	glb->txt_ovl_status = 0;
	glb->input_filename = NULL;
	glb->output_filename = NULL;
	glb->drill_guide_filename = NULL;
	glb->aperture_filename = "aperture.dat";
	glb->txt_ovl_filename = NULL;

	return 0;
}

/**
  * GCONV_parse_parameters
  *
  * Parses the command line parameters and sets the
  * various convgerber settings accordingly
  */
int GCONV_parse_parameters( int argc, char **argv, struct gconv_glb *glb )
{

	char c;

	do {
		c = getopt(argc, argv, "i:o:g:l:vh");
		switch (c) { 
			case EOF: /* finished */
				break;

			case 'i':
				glb->input_filename = strdup(optarg);
				break;

			case 'o':
				glb->output_filename = strdup(optarg);
				break;

			case 'g':
				glb->drill_guide_status = 1;
				glb->drill_guide_filename = strdup(optarg);
				break;

			case 'l':
				glb->txt_ovl_status = 1;
				glb->txt_ovl_filename = strdup(optarg);
				break;

			case 'h':
				GCONV_show_help(glb);
				exit(1);
				break;

			case 'v':
				GCONV_show_version(glb);
				exit(1);
				break;

			case '?':
				break;

			default:
				fprintf(stderr, "internal error with getopt\n");
				exit(1);
				
		} /* switch */
	} while (c != EOF); /* do */
	return 0;
}
/**
 * GCONV_get_file_size
 * return size of file in bytes
 */ 

int GCONV_get_file_size (FILE* fp)
{
	struct stat st;
	int fd;

	/* Convert file pointer to file number (integer) */
	fd = fileno(fp);
	/* Get info about file */
	if ( fstat(fd, &st) ) { 
        printf("\nfstat error: [%s]\n",strerror(errno));  
        return -1; 
    }
    /* Return size of file */ 
	return st.st_size;
}

/**
  * GCONV_check_input_file
  *
  * Check if input file is a Protel file
  * First 5 bytes should be "X0Y0*"
  * Files appear to written in 512 byte
  * blocks
  * BS (0x08) appears to be the marker for
  * the beginning of the last block
  * file length mod 512 should be 0
  * byte at file length less 512 should be BS (0x08)
  * first five bytes should be X0Y0*
  * If the file passes those 3 tests we should
  * have a vaild file, barring any illegal characters
  * 
  */ 
int GCONV_check_input_file( FILE* fp )
{
	char file_sig[6];
	int file_size;
	
	/* Attempt to get file size */
	file_size = GCONV_get_file_size(fp);
	if ( file_size == -1 ) {
		return ERR_GET_FILE_SIZE;
	}

	/* Is file size made up of full 512 byte blocks */
	else if ( file_size % 2 != 0 ) {
		return ERR_SIZE_WRONG;
	}
	
	/* Get first 5 bytes as a string */
	fgets( file_sig, 6, fp);
	/* Move to beginning of last 512 block */
	fseek (fp, -512, SEEK_END);

	/* check for X0Y0* at begining of file */	
	if ( strcmp(AUTOTRAX_FILE_START_STRING, file_sig) !=0  ) {
		return ERR_SIG_WRONG;
	}
	
	//* check for BS at beginning of last 512 byte block
	if ( fgetc(fp) != BS ) {
		return ERR_NO_BS_MAKER;
	}
	
	/* Return file pointer to beginning of file */
	fseek (fp, 0, SEEK_SET);
	return 0;
}

/**
  * GCONV_write_header
  *
  * Writer header to output file
  * 
  */
int GCONV_write_header( FILE *f_new )
{
	fprintf(f_new,"%s\n", GCONV_HEADER);

	return 0;
}
/**
  * GCONV_write_apperatures
  *
  * Writer aperture definitions to output file
  * 
  */
int GCONV_write_apertures( FILE *f_new, FILE *f_apt )
{
		int aperture_read;
		fprintf( f_new, APT_LIST_START );
		
		while (  ( aperture_read = fgetc(f_apt) ) != EOF ) { 
			
			fputc( aperture_read, f_new );
		}
		fprintf( f_new, APT_LIST_END );
	return 0;
}
/**
  * GCONV_set_layer_dark
  *
  * Set Layer Polarity to dark
  * 
  */
int GCONV_set_layer_dark( FILE *f_new )
{
	fprintf(f_new,"%s", LAYER_POLARITY_DARK);

	return 0;
}
/**
  * GCONV_convert_format
  *
  * Converts raw file to new format
  * Removes white space &
  * adds NEWLINE after each "*". Function ends
  * when "M" is reached as "M02" designates end
  * of data
  * Was going to read file by 512 blocks
  * now thinking reading with fgetc allows
  * picking up of illegal characters at the
  * expense of slightly longer conversion time
  */
int GCONV_convert_format( FILE* f_old, FILE* f_new) 
{	
		int gerber_read;
		int curr_pos;


		/* Read source file a character at a time */
		 while (  ( gerber_read = fgetc(f_old) ) != EOF ) {
				

				switch (gerber_read) {
					
		/* If we have "*" write "*\n" to destination file */					
					case GERBER_TERM:
						fprintf(f_new, "*\n"); 
						break;
		/* Ignore Backspace, Line feed (newline), Form feed, Carriage return & space */
					case BS :
					case LF :
					case FF :
					case CR :
					case SPACE :
						break;
		/* Write X,Y, cordinates, D-codes, to destination file */
 
					case 'X' :
					case 'Y' :
					case 'D' :
					/* Covers 0 to 9 */					
					case '0' ... '9':
						fputc( gerber_read, f_new );
						break;

		/* M02 designates end of program we can exit */
		/* M02 is not written here as this would not */
		/* allow the program to combine the drillguide file */ 
					case 'M' :
						return 0;

		/* If we get here we have an "illegal character" */ 					
						default :
						curr_pos=(ftell(f_old) -1);
						fprintf( stderr, "Error: Illegal character found.\n Hex value = 0x%.2x\n At position 0x%.8x\n", gerber_read, curr_pos);
						return ERR_ILLEGAL_CHAR;
					}
	}
	/* if we get here it means we are missing our M02 code */
	return ERR_MISSING_M02;
}


/**
  * GCONV_set_layer_clear
  *
  * Set Layer Polarity to clear
  * 
  */
int GCONV_set_layer_clear( FILE *f_new )
{
	fprintf(f_new,"%s", LAYER_POLARITY_CLEAR);

	return 0;
}

/**
  * GCONV_write_stop_m02
  *
  * Terminate file with M02*
  * 
  */
int GCONV_write_stop_m02( FILE *f_new )
{
	fprintf(f_new,"%s", STOP_MO2);

	return 0;
}







/**
  * convgerber,  main body
  *
  * This program inputs an existing Protel Autotrax Gerber file which
  * does not conform with later formats
  */
int main(int argc, char **argv) {

	struct gconv_glb glb;
	FILE *f_input, *f_output, *f_aperture, *f_drill_guide, *f_txt_ovl;
	int file_check;
	
	/* Initialize our global data structure */
	GCONV_init(&glb);


	/* Parse & decypher the command line parameters provided */
	GCONV_parse_parameters(argc, argv, &glb);
	

	/* Check the fundamental sanity of the variables in
		the global data structure to ensure that we can
		actually perform some meaningful work
		*/
	if ((glb.input_filename == NULL)) {
		fprintf(stderr,"Error: Input filename is NULL.\n");
		exit(1);
	}
	if ((glb.output_filename == NULL)) {
		fprintf(stderr,"Error: Output filename is NULL.\n");
		exit(1);
	}
	
	if ((glb.drill_guide_filename == NULL) && (glb.drill_guide_status != 0)) {
		fprintf(stderr,"Error: Drill guide filename is NULL.\n");
		exit(1);
	}		
	
	if ((glb.txt_ovl_filename == NULL) && (glb.txt_ovl_status != 0)) {
		fprintf(stderr,"Error: Text overlay filename is NULL.\n");
		exit(1);
	}

//* Input		
	/* Attempt to open input file as read only */ 
	f_input = fopen(glb.input_filename,"r");
	if (!f_input) {
		fprintf(stderr,"Error: Cannot open input file '%s' for reading (%s)\n", glb.input_filename, strerror(errno));
		return ERR_NOT_OPEN_INPUT;
	}
	
	/* Check if input file is valid */
	file_check = GCONV_check_input_file( f_input );
	if  ( file_check != 0 )  {
		fprintf( stderr, "Error: %s does not appear to be a valid Autotrax gerber file\n", glb.input_filename );
		return ERR_NOT_VALID_INPUT;
	}

//* Drill Guide
	/* Attempt to open drill guide  file as read only */ 
	if ( glb.drill_guide_status == 1 ) {
		f_drill_guide = fopen(glb.drill_guide_filename,"r");
			if (!f_drill_guide) {
				fprintf(stderr,"Error: Cannot open input file '%s' for reading (%s)\n", glb.drill_guide_filename, strerror(errno));
				return ERR_NOT_OPEN_DRILL_GUIDE;
	}

	/* Check if drill guide file is valid */
	file_check = GCONV_check_input_file( f_drill_guide );
		if  ( file_check != 0 )  {
			fprintf( stderr, "Error: %s does not appear to be a valid Autotrax gerber file\n", glb.drill_guide_filename );
			return ERR_NOT_VALID_DRILL_GUIDE;
		}
	}

//* Overlay
	/* Attempt to open overlay  file as read only */ 
	if ( glb.txt_ovl_status == 1 ) {
		f_txt_ovl = fopen(glb.txt_ovl_filename,"r");
		if (!f_txt_ovl) {
			fprintf(stderr,"Error: Cannot open input file '%s' for reading (%s)\n", glb.txt_ovl_filename, strerror(errno));
			return ERR_NOT_OPEN_TXT_OVL;
			}

	/* Check if overlay file is valid */
	file_check = GCONV_check_input_file( f_txt_ovl );
	if  ( file_check != 0 )  {
		fprintf( stderr, "Error: %s does not appear to be a valid Autotrax gerber file\n", glb.txt_ovl_filename );
		return ERR_NOT_VALID_TXT_OVL;
		}
	}

//* Aperture	
	/* Attempt to open the aperture file as read-only */
	f_aperture = fopen(glb.aperture_filename,"r");
	if (!f_aperture) {
		fprintf(stderr,"Error: Cannot open aperture data file '%s' for reading (%s)\n", glb.aperture_filename, strerror(errno));
		return ERR_NOT_OPEN_APERTURE;
	}

//* Output
	/* Attempt to open the output file in write mode */
	/*	(no appending is done, any existing file will be */
	/*	overwritten */
	f_output = fopen(glb.output_filename,"w");
	if (!f_output) {
		fprintf(stderr,"Error: Cannot open output file '%s' for writing (%s)\n", glb.output_filename, strerror(errno));
		return ERR_NOT_OPEN_OUTPUT;
	}
		
	/* Write header & aperture definitions to output file */
	GCONV_write_header (f_output);
	GCONV_write_apertures(f_output ,f_aperture);

	/* Set layer to "dark" as drill guide & overlay is set to "clear" */
	GCONV_set_layer_dark(f_output);
	GCONV_convert_format(f_input, f_output);

	/* If given a drill guide file convert & merge */	
	if ( glb.drill_guide_status == 1 ) {
		fprintf( f_output, "G04 Drill guide section *\n");
		/* Set layer to "clear" so drill guides show up */
		GCONV_set_layer_clear(f_output);
		GCONV_convert_format(f_drill_guide, f_output);
		fclose(f_drill_guide);
	}
	
	/* If given a txt overlay file convert & merge */	
	if ( glb.txt_ovl_status == 1 ) {
		fprintf( f_output, "G04 Overlay section *\n");
		/* Set layer to "clear" so overlay show up */
		GCONV_set_layer_clear(f_output);
		GCONV_convert_format(f_txt_ovl, f_output);
		fclose(f_txt_ovl);
	}
	
	/* Write M02 "stop" code */	
	GCONV_write_stop_m02(f_output);
	
	/* Close open files */
	fclose(f_output);
	fclose(f_input);
	fclose(f_aperture);
	
	/* Display message of success */
	printf("Autotrax file successfully converted\n");
	return 0;
}	
